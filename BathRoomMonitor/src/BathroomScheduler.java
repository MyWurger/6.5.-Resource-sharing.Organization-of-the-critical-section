import java.util.Scanner;                           // импортируем класс Scanner для считывания ввода от пользователя


public class BathroomScheduler
{
    private final int BUFFER_SIZE = 3;              // глобальная константа, которая определяет размер буфера, который будет использоваться для отслеживания доступа к ванной комнате
    private int[] buffer = new int[BUFFER_SIZE];    // объявление и выделение памяти "в одном флаконе" под массив для хранения информации о том, кто находится в ванной комнате (0 - никого, 1 - мужчина, 2 - женщина)
    private int in = 0;                             // индекс для добавления (in) записи о входе человека в ванную комнату  
    private int out = 0;                            // индекс для добавления (out) записи о выходе человека из ванной комнаты
    private int count = 0;                          // счётчик для отслеживания количества человек в ванной комнате
    private int male_inside = 0;                    // текущее количество мужчин в ванной комнате
    private int female_inside = 0;                  // текущее количество женщин в ванной комнате
    private int male_total;                         // общее количество мужчин, которые должны посетить ванную комнату
    private int female_total;                       // общее количество женщин,которые должны посетить ванную комнату
    private boolean turn = true;                    // флаг, определяющий, чья очередь сейчас (true - мужчин, false - женщин)


    // конструктор класса, который устанавливает количества мужчин и женщин, введённые пользователем
    public BathroomScheduler(int maleTotal, int femaleTotal) 
    {
        // используем this, чтобы отличить поля от передаваемых значений
        this.male_total = maleTotal;                // устанавливаем количество мужчин, которые участвуют в делёжке ванной комнаты   
        this.female_total = femaleTotal;            // устанавливаем количество женщин, которые участвуют в делёжке ванной комнаты
    }// BathroomScheduler()


    // публичный синхронизированный метод для имитации входа мужчины в ванную комнату
    // если поток, выполняющий этот метод, будет прерван командой wait, то будет выброшено исключение InterruptedException, если запустится другой поток. 
    // вызывающий код должен быть готов обработать это исключение
    public synchronized void enterMale() throws InterruptedException 
    {
        // ожидаем, пока есть женщины в ванной комнате, нет места в ванной комнате или очередь заходить в ванную комнату у женщин
        while (female_inside > 0 || (turn == false && male_inside == 0) || count == BUFFER_SIZE) 
        {
            // если поток был прерван во время ожидания, то при возобновлении работы он должен обработать InterruptedException
            wait();                                 // освобождаем монитор (lock), который был получен потоком при входе в синхронизированный метод, и переводим поток в состояние ожидания
        }// while

        // иначе - мужчина может зайти в ванную комнату: ванная комната свободна или в ней есть свободное место для мужчины
        male_inside = male_inside + 1;              // увеличиваем количество мужчин в ванной комнате
        male_total = male_total - 1;                // сокращаем общее количество мужчин, которое должно пройти через ванную комнату
        count = count + 1;                          // увеличиваем счётчик количества человек в ванной комнате: для отслеживания её переполнения

        // если в ванную комнату вошел первый мужчина, и есть ожидающие женщины, устанавливаем флаг очереди для женщин. При освобождении ванной комнаты начнут заходить женщины
        if (male_inside == 1 && female_total > 0) 
        {
            turn = false;                           // устанавливаем флаг, что при освобождении ванной комнаты в неё должны начать заходить женщины
        }// if

        buffer[in] = 1;                             // добавляем элемент в буфер - очередной мужчина зашёл в ванную комнату
        in = (in + 1) % BUFFER_SIZE;                // обновляем индекс добавления - буфер кольцевой, то есть мы делим полученный индекс на размер буфера и берём остаток
        
        // подкрашиваем, что мужчина вошел в ванную комнату
        System.out.println("Мужчина вошел в ванную. Мужчин в ванной: " + count + ", Женщин в ванной: " + female_inside);
        
        // использование notifyAll() вместо notify() может быть предпочтительнее, когда несколько потоков ожидают на одном объекте. В нашем случае wait
        notifyAll();                                // пробуждаем все ожидающие потоки, чтобы они могли проверить условия и продолжить
    }// enterMale()


    // публичный синхронизированный метод для имитации выхода мужчины из ванной комнаты
    // этот метод уже не может прерваться, так как нет в нем соответствующих функций типа wait()
    public synchronized void exitMale() 
    {
        male_inside = male_inside - 1;              // уменьшаем количество мужчин в ванной комнате
        count = count - 1;                          // уменьшаем счётчик количества человек в ванной комнате: для отслеживания её переполнения
        buffer[out] = 0;                            // удаляем элемент из ванной комнаты
        out = (out + 1) % BUFFER_SIZE;              // обновляем индекс удаления с учетом того, что буфер-кольцевой

        // подкрашиваем, что мужчина вышел из ванной комнаты
        System.out.println("Мужчина вышел из ванной. Мужчин в ванной: " + count + ", Женщин в ванной: " + female_inside);
        
        // если последний мужчина вышел из ванной комнаты и есть ожидающие женщины, устанавливаем флаг очереди для женщин
        if (male_inside == 0 && female_total > 0) 
        {
            // выводим, сколько женщин ожидают доступа в ванную комнату
            System.out.println("Женщин в очереди: " + female_total + "\n");
            turn = false;                           // устанавливаем флаг, что при освобождении ванной комнаты в неё должны начать заходить женщины
        }// if

        // использование notifyAll() вместо notify() может быть предпочтительнее, когда несколько потоков ожидают на одном объекте. В нашем случае wait
        notifyAll();                                // пробуждаем все ожидающие потоки, чтобы они могли проверить условия и продолжить
    }// exitMale()


    // публичный синхронизированный метод для имитации входа женщины в ванную комнату
    // если поток, выполняющий этот метод, будет прерван командой wait, то будет выброшено исключение InterruptedException, если запустится другой поток. 
    // вызывающий код должен быть готов обработать это исключение
    public synchronized void enterFemale() throws InterruptedException 
    {
        // ожидаем, пока есть мужчины в ванной комнате, нет места в ванной комнате или очередь заходить в ванную комнату у женщин
        while (male_inside > 0 || (turn == true && female_inside == 0) || count == BUFFER_SIZE) 
        {
            // если поток был прерван во время ожидания, то при возобновлении работы он должен обработать InterruptedException
            wait();                                 // освобождаем монитор (lock), который был получен потоком при входе в синхронизированный метод, и переводим поток в состояние ожидания
        }// while

        // иначе - женщина может зайти в ванную комнату: ванная комната свободна или в ней есть свободное место для женщины
        female_inside = female_inside + 1;          // увеличиваем количество женщин в ванной комнате
        female_total = female_total - 1;            // сокращаем общее количество женщин, которое должно пройти через ванную комнату
        count = count + 1;                          // увеличиваем счётчик количества человек в ванной комнате: для отслеживания её переполнения

        // если в ванную комнату вошла первая женщина, и есть ожидающие мужчины, устанавливаем флаг очереди для мужчин. При освобождении ванной комнаты начнут заходить мужчины
        if (female_inside == 1 && male_total > 0) 
        {
            turn = true;                            // устанавливаем флаг, что при освобождении ванной комнаты в неё должны начать заходить мужчины
        }// if

        buffer[in] = 2;                             // добавляем элемент в буфер - очередная женщина зашла в ванную комнату
        in = (in + 1) % BUFFER_SIZE;                // обновляем индекс добавления - буфер кольцевой, то есть мы делим полученный индекс на размер буфера и берём остаток

        // подкрашиваем, что женщина вошла в ванную комнату
        System.out.println("Женщина вошла в ванную. Мужчин в ванной: " + male_inside + ", Женщин в ванной: " + count);
        
        // использование notifyAll() вместо notify() может быть предпочтительнее, когда несколько потоков ожидают на одном объекте. В нашем случае wait
        notifyAll();                                // пробуждаем все ожидающие потоки, чтобы они могли проверить условия и продолжить
    }// enterFemale()


    // публичный синхронизированный метод для имитации выхода женщины из ванной комнаты
    // этот метод уже не может прерваться, так как нет в нем соответствующих функций типа wait()
    public synchronized void exitFemale() 
    {
        female_inside = female_inside - 1;          // уменьшаем количество женщин в ванной комнате
        count = count - 1;                          // уменьшаем счётчик количества человек в ванной комнате: для отслеживания её переполнения
        buffer[out] = 0;                            // удаляем элемент из ванной комнаты
        out = (out + 1) % BUFFER_SIZE;              // обновляем индекс удаления с учетом того, что буфер-кольцевой
        
        // подкрашиваем, что женщина вышла из ванной комнаты
        System.out.println("Женщина вышла из ванной. Мужчин в ванной: " + male_inside + ", Женщин в ванной: " + count);
        
        // если последняя женщина вышла из ванной комнаты и есть ожидающие мужчины, устанавливаем флаг очереди для мужчин
        if (female_inside == 0 && male_total > 0) 
        {
            // выводим, сколько мужчин ожидают доступа в ванную комнату
            System.out.println("Мужчин в очереди: " + male_total + "\n");
            turn = true;                            // устанавливаем флаг, что при освобождении ванной комнаты в неё должны начать заходить мужчины
        }// if

        // использование notifyAll() вместо notify() может быть предпочтительнее, когда несколько потоков ожидают на одном объекте. В нашем случае wait
        notifyAll();                                // пробуждаем все ожидающие потоки, чтобы они могли проверить условия и продолжить
    }// exitFemale()


    // main-метод, который запускает программу
    public static void main(String[] args) 
    {
        // создаем объект класса Scanner для считывания ввода пользователя
        Scanner scanner = new Scanner(System.in);   // связываем созданный объект со стандартным вводом

        // запрашиваем у пользователя количество мужчин
        System.out.print("Введите количество мужчин: ");
        int numMales = scanner.nextInt();           // считываем целое число, введенное пользователем в консоль через объект scanner

        // запрашиваем у пользователя количество женщин
        System.out.print("Введите количество женщин: ");
        int numFemales = scanner.nextInt();         // считываем целое число, введенное пользователем в консоль через объект scanner

        // создаем объект класса BathroomScheduler с введенными значениями, используя конструктор
        BathroomScheduler scheduler = new BathroomScheduler(numMales, numFemales);

        // запускаем потоки для имитации входа мужчин в ванную комнату
        for (int i = 0; i < numMales; i++) 
        {
            // создаём новый поток с использованием лямбда-выражения с учетом того, что при создании используется один и тот же экземпляр класса, потому все описанные переменные и их изменения видны всем созданным потокам
            // суть лямбда-выражений:
            // когда вы запускаете новый поток, вы передаете ему объект Runnable, который содержит код, который должен выполняться в новом потоке.
            // когда новый поток запускается, он создает свое собственное стековое пространство и выполняет код, содержащийся в объекте Runnable.
            new Thread(() ->{
                // работа в плановом режиме
                try 
                {
                    scheduler.enterMale();          // вызываем метод экземпляра класса для управления входом мужчин в ванную комнату
                    Thread.sleep(300);              // имитируем время нахождения мужчины в ванной комнате
                    scheduler.exitMale();           // вызываем метод экземпляра класса для управления выходом мужчины из ванной комнаты
                }
                // когда поток находится в состоянии ожидания (например, при вызове wait(), sleep())
                // он прерывается. Ловим прерывание
                catch (InterruptedException e) 
                {
                    // устанавливаем флаг прерывания для текущего потока
                    // это означает, что флаг прерывания текущего потока будет установлен в true, указывая на то, что поток был прерван
                    Thread.currentThread().interrupt();
                    // когда у потока установлен флаг прерывания, это позволяет другим частям кода определить, что поток был прерван, и
                    // принять соответствующие действия
                }
            }).start();
        }// for i

        // запускаем потоки для имитации входа женщин в ванную комнату
        for (int i = 0; i < numFemales; i++) 
        {
            // создаём новый поток с использованием лямбда-выражения с учетом того, что при создании используется один и тот же экземпляр класса, потому все описанные переменные и их изменения видны всем созданным потокам
            // суть лямбда-выражений:
            // когда вы запускаете новый поток, вы передаете ему объект Runnable, который содержит код, который должен выполняться в новом потоке.
            // когда новый поток запускается, он создает свое собственное стековое пространство и выполняет код, содержащийся в объекте Runnable.
            new Thread(() ->{
                // работа в плановом режиме
                try 
                {
                    scheduler.enterFemale();        // вызываем метод экземпляра класса для управления входом женщин в ванную комнату
                    Thread.sleep(300);              // имитируем время нахождения женщины в ванной комнате
                    scheduler.exitFemale();         // вызываем метод экземпляра класса для управления выходом женщины из ванной комнаты
                }
                // когда поток находится в состоянии ожидания (например, при вызове wait(), sleep())
                // он прерывается. Ловим прерывание 
                catch (InterruptedException e) 
                {
                    // устанавливаем флаг прерывания для текущего потока
                    // это означает, что флаг прерывания текущего потока будет установлен в true, указывая на то, что поток был прерван
                    Thread.currentThread().interrupt();
                    // когда у потока установлен флаг прерывания, это позволяет другим частям кода определить, что поток был прерван, и
                    // принять соответствующие действия
                }
            }).start();
        }// for i

        scanner.close();                            // закрываем объект класса Scanner       
    
    }// main()

}// BathroomScheduler