import java.util.Scanner;                           // импортируем класс Scanner для считывания ввода от пользователя
import java.util.ArrayList;                         // импортируем класс ArrayList для работы со списками
import java.util.List;                              // импортируем интерфейс List для работы со списками



/**************************************************************/
/*            О С Н О В Н А Я   П Р О Г Р А М М А             */
/**************************************************************/

// класс, отвечающий за выполняемую программу
public class BathroomScheduler
{

    /**************************************************************************/
    /*   П Е Р Е М Е Н Н Ы Е   К Л А С С А   */
    /*****************************************/

    private final int BUFFER_SIZE = 3;              // глобальная константа, которая определяет размер буфера, который будет использоваться для отслеживания доступа к ванной комнате
    private int[] buffer = new int[BUFFER_SIZE];    // объявление и выделение памяти "в одном флаконе" под массив для хранения информации о том, кто находится в ванной комнате (0 - никого, 1 - мужчина, 2 - женщина)
    private int in = 0;                             // индекс для добавления (in) записи о входе человека в ванную комнату  
    private int out = 0;                            // индекс для добавления (out) записи о выходе человека из ванной комнаты
    private int count = 0;                          // счётчик для отслеживания количества человек в ванной комнате
    private int male_inside = 0;                    // текущее количество мужчин в ванной комнате
    private int female_inside = 0;                  // текущее количество женщин в ванной комнате
    private int male_total;                         // общее количество мужчин, которые должны посетить ванную комнату
    private int female_total;                       // общее количество женщин,которые должны посетить ванную комнату
    private boolean turn = true;                    // флаг, определяющий, чья очередь сейчас (true - мужчин, false - женщин)



    /**************************************************************************/
    /*   М Е Т О Д Ы   К Л А С С А   */
    /*********************************/

    /*----------------------------------------------------------*/
    /*         Конструктор класса         */
    /*------------------------------------*/
    // конструктор класса, который устанавливает количества мужчин и женщин, введённые пользователем
    public BathroomScheduler(int maleTotal,         // количество мужчин, введённое пользователем
                             int femaleTotal)       // количество женщин, введённое пользователем
    {
        // используем this, чтобы отличить поля от передаваемых значений
        this.male_total = maleTotal;                // устанавливаем количество мужчин, которые участвуют в делёжке ванной комнаты   
        this.female_total = femaleTotal;            // устанавливаем количество женщин, которые участвуют в делёжке ванной комнаты
        return;                                     // возвращаем обещанное значение конструктором
    }// BathroomScheduler()


    /*----------------------------------------------------------*/
    /*       Приветственная надпись       */
    /*------------------------------------*/
    // печать приветственного ASCII-арта на экран
    public void print_start()
    {
        // выводим ASCII-арт начала
        System.out.println("\n\033[38;5;121m            ___       _,.---._      .-._           .=-.-.  ,--.--------.      _,.---._                      ,-,--.");
        System.out.println("     .-._ .'=.'\\    ,-.' , -  `.   /==/ \\  .-._   /==/_ / /==/,  -   , -\\   ,-.' , -  `.     .-.,.---.    ,-.'-  _\\");
        System.out.println("    /==/ \\|==|  |  /==/_,  ,  - \\  |==|, \\/ /, / |==|, |  \\==\\.-.  - ,-./  /==/_,  ,  - \\   /==/  `   \\  /==/_ ,_.'");
        System.out.println("    |==|,|  / - | |==|   .=.     | |==|-  \\|  |  |==|  |   `--`\\==\\- \\    |==|   .=.     | |==|-, .=., | \\==\\  \\");
        System.out.println("    |==|  \\/  , | |==|_ : ;=:  - | |==| ,  | -|  |==|- |        \\==\\_ \\   |==|_ : ;=:  - | |==|   '='  /  \\==\\ -\\");
        System.out.println("    |==|- ,   _ | |==| , '='     | |==| -   _ |  |==| ,|        |==|- |   |==| , '='     | |==|- ,   .'   _\\==\\ ,\\");
        System.out.println("    |==| _ /\\   |  \\==\\ -    ,_ /  |==|  /\\ , |  |==|- |        |==|, |    \\==\\ -    ,_ /  |==|_  . ,'.  /==/\\/ _ |");
        System.out.println("    /==/  / / , /   '.='. -   .'   /==/, | |- |  /==/. /        /==/ -/     '.='. -   .'   /==/  /\\ ,  ) \\==\\ - , /");
        System.out.println("    `--`./  `--`      `--`--''     `--`./  `--`  `--`-`         `--`--`       `--`--''     `--`-`--`--'   `--`---'\033[0m\n\n");
        return;                                     // вернули обещанное значение методом            
    }// print_start()


    /*----------------------------------------------------------*/
    /*         Прощальная надпись        */
    /*-----------------------------------*/
    // печать прощального ASCII-арта на экран
    public void print_end()
    {
        // выводим ASCII-арт начала
        System.out.println("\n\t\t\033[38;5;121m ,--.--------.   ,--.-,,-,--,      ,----.             ,----.   .-._");
        System.out.println("\t\t/==/,  -   , -\\ /==/  /|=|  |   ,-.--` , \\         ,-.--` , \\ /==/ \\  .-._    _,..---._");
        System.out.println("\t\t\\==\\.-.  - ,-./ |==|_ ||=|, |  |==|-  _.-`        |==|-  _.-` |==|, \\/ /, / /==/,   -  \\");
        System.out.println("\t\t `--`\\==\\- \\    |==| ,|/=| _|  |==|   `.-.        |==|   `.-. |==|-  \\|  |  |==|   _   _\\");
        System.out.println("\t\t      \\==\\_ \\   |==|- `-' _ | /==/_ ,    /       /==/_ ,    / |==| ,  | -|  |==|  .=.   |");
        System.out.println("\t\t      |==|- |   |==|  _     | |==|    .-'        |==|    .-'  |==| -   _ |  |==|,|   | -|");
        System.out.println("\t\t      |==|, |   |==|   .-. ,\\ |==|_  ,`-._       |==|_  ,`-._ |==|  /\\ , |  |==|  '='   /");
        System.out.println("\t\t      /==/ -/   /==/, //=/  | /==/ ,     /       /==/ ,     / /==/, | |- |  |==|-,   _`/");
        System.out.println("\t\t      `--`--`   `--`-' `-`--` `--`-----``        `--`-----``  `--`./  `--`  `-.`.____.'\033[0m\n");
        return;                                     // вернули обещанное значение методом           
    }// print_end()


    /*----------------------------------------------------------*/
    /*          Вход мужчины         */
    /*-------------------------------*/
    // публичный синхронизированный метод для имитации входа мужчины в ванную комнату
    // если поток, выполняющий этот метод, будет прерван командой wait, то будет выброшено исключение InterruptedException, если запустится другой поток
    // вызывающий код должен быть готов обработать это исключение
    public synchronized void enterMale() throws InterruptedException 
    {
        // ожидаем, пока есть женщины в ванной комнате, нет места в ванной комнате или очередь заходить в ванную комнату у женщин
        while (female_inside > 0 || (turn == false && male_inside == 0) || count == BUFFER_SIZE) 
        {
            // если поток был прерван во время ожидания, то при возобновлении работы он должен обработать InterruptedException
            wait();                                 // освобождаем монитор (lock), который был получен потоком при входе в синхронизированный метод, и переводим поток в состояние ожидания
        }// while

        // иначе - мужчина может зайти в ванную комнату: ванная комната свободна или в ней есть свободное место для мужчины
        male_inside = male_inside + 1;              // увеличиваем количество мужчин в ванной комнате
        male_total = male_total - 1;                // сокращаем общее количество мужчин, которое должно пройти через ванную комнату
        count = count + 1;                          // увеличиваем счётчик количества человек в ванной комнате: для отслеживания её переполнения

        // если в ванную комнату вошел первый мужчина, и есть ожидающие женщины, устанавливаем флаг очереди для женщин. При освобождении ванной комнаты начнут заходить женщины
        if (male_inside == 1 && female_total > 0) 
        {
            turn = false;                           // устанавливаем флаг, что при освобождении ванной комнаты в неё должны начать заходить женщины
        }// if

        // в ванной комнате не было людей, и зашёл в неё мужчина - подкрашиваем это
        if (male_inside == 1)
        {
            System.out.print("\n\033[38;5;135mМ У Ж Ч И Н Ы   В Х О Д Я Т:\033[0m\n");
        }// if

        buffer[in] = 1;                             // добавляем элемент в буфер - очередной мужчина зашёл в ванную комнату
        in = (in + 1) % BUFFER_SIZE;                // обновляем индекс добавления - буфер кольцевой, то есть мы делим полученный индекс на размер буфера и берём остаток
        
        // подкрашиваем, что мужчина вошел в ванную комнату
        System.out.println("Мужчина вошел в ванную. Мужчин в ванной: " + count + ", Женщин в ванной: " + female_inside);
        
        // использование notifyAll() вместо notify() может быть предпочтительнее, когда несколько потоков ожидают на одном объекте. В нашем случае wait
        notifyAll();                                // пробуждаем все ожидающие потоки, чтобы они могли проверить условия и продолжить
        return;                                     // возвращаем обещанное значение
    }// enterMale()


    /*----------------------------------------------------------*/
    /*          Выход мужчины         */
    /*--------------------------------*/
    // публичный синхронизированный метод для имитации выхода мужчины из ванной комнаты
    // этот метод уже не может прерваться, так как нет в нем соответствующих функций типа wait()
    public synchronized void exitMale() 
    {
        male_inside = male_inside - 1;              // уменьшаем количество мужчин в ванной комнате
        count = count - 1;                          // уменьшаем счётчик количества человек в ванной комнате: для отслеживания её переполнения
        buffer[out] = 0;                            // удаляем элемент из ванной комнаты
        out = (out + 1) % BUFFER_SIZE;              // обновляем индекс удаления с учетом того, что буфер-кольцевой

        // подкрашиваем, что мужчина вышел из ванной комнаты
        System.out.println("Мужчина вышел из ванной. Мужчин в ванной: " + count + ", Женщин в ванной: " + female_inside);
        
        // если последний мужчина вышел из ванной комнаты и есть ожидающие женщины, устанавливаем флаг очереди для женщин
        if (male_inside == 0 && female_total > 0) 
        {
            // выводим, сколько женщин ожидают доступа в ванную комнату
            System.out.print("\n\033[38;5;198mЖенщин\033[38;5;122m осталось в очереди: " + female_total + "\033[0m\n");
            turn = false;                           // устанавливаем флаг, что при освобождении ванной комнаты в неё должны начать заходить женщины
        }// if

        // использование notifyAll() вместо notify() может быть предпочтительнее, когда несколько потоков ожидают на одном объекте. В нашем случае wait
        notifyAll();                                // пробуждаем все ожидающие потоки, чтобы они могли проверить условия и продолжить
    }// exitMale()


    /*----------------------------------------------------------*/
    /*          Вход женщины        */
    /*------------------------------*/
    // публичный синхронизированный метод для имитации входа женщины в ванную комнату
    // если поток, выполняющий этот метод, будет прерван командой wait, то будет выброшено исключение InterruptedException, если запустится другой поток. 
    // вызывающий код должен быть готов обработать это исключение
    public synchronized void enterFemale() throws InterruptedException 
    {
        // ожидаем, пока есть мужчины в ванной комнате, нет места в ванной комнате или очередь заходить в ванную комнату у женщин
        while (male_inside > 0 || (turn == true && female_inside == 0) || count == BUFFER_SIZE) 
        {
            // если поток был прерван во время ожидания, то при возобновлении работы он должен обработать InterruptedException
            wait();                                 // освобождаем монитор (lock), который был получен потоком при входе в синхронизированный метод, и переводим поток в состояние ожидания
        }// while

        // иначе - женщина может зайти в ванную комнату: ванная комната свободна или в ней есть свободное место для женщины
        female_inside = female_inside + 1;          // увеличиваем количество женщин в ванной комнате
        female_total = female_total - 1;            // сокращаем общее количество женщин, которое должно пройти через ванную комнату
        count = count + 1;                          // увеличиваем счётчик количества человек в ванной комнате: для отслеживания её переполнения

        // если в ванную комнату вошла первая женщина, и есть ожидающие мужчины, устанавливаем флаг очереди для мужчин. При освобождении ванной комнаты начнут заходить мужчины
        if (female_inside == 1 && male_total > 0) 
        {
            turn = true;                            // устанавливаем флаг, что при освобождении ванной комнаты в неё должны начать заходить мужчины
        }// if

        // в ванной комнате не было людей и зашла в неё женщина - подкрашиваем это
        if (female_inside == 1)
        {
            System.out.print("\n\033[38;5;198mЖ Е Н Щ И Н Ы   В Х О Д Я Т:\033[0m\n");
        }// if

        buffer[in] = 2;                             // добавляем элемент в буфер - очередная женщина зашла в ванную комнату
        in = (in + 1) % BUFFER_SIZE;                // обновляем индекс добавления - буфер кольцевой, то есть мы делим полученный индекс на размер буфера и берём остаток

        // подкрашиваем, что женщина вошла в ванную комнату
        System.out.println("Женщина вошла в ванную. Мужчин в ванной: " + male_inside + ", Женщин в ванной: " + count);
        
        // использование notifyAll() вместо notify() может быть предпочтительнее, когда несколько потоков ожидают на одном объекте. В нашем случае wait
        notifyAll();                                // пробуждаем все ожидающие потоки, чтобы они могли проверить условия и продолжить
    }// enterFemale()


    /*----------------------------------------------------------*/
    /*          Выход женщины         */
    /*--------------------------------*/
    // публичный синхронизированный метод для имитации выхода женщины из ванной комнаты
    // этот метод уже не может прерваться, так как нет в нем соответствующих функций типа wait()
    public synchronized void exitFemale() 
    {
        female_inside = female_inside - 1;          // уменьшаем количество женщин в ванной комнате
        count = count - 1;                          // уменьшаем счётчик количества человек в ванной комнате: для отслеживания её переполнения
        buffer[out] = 0;                            // удаляем элемент из ванной комнаты
        out = (out + 1) % BUFFER_SIZE;              // обновляем индекс удаления с учетом того, что буфер-кольцевой
        
        // подкрашиваем, что женщина вышла из ванной комнаты
        System.out.println("Женщина вышла из ванной. Мужчин в ванной: " + male_inside + ", Женщин в ванной: " + count);
        
        // если последняя женщина вышла из ванной комнаты и есть ожидающие мужчины, устанавливаем флаг очереди для мужчин
        if (female_inside == 0 && male_total > 0) 
        {
            // выводим, сколько мужчин ожидают доступа в ванную комнату
            System.out.print("\n\033[38;5;135mМужчин\033[38;5;122m осталось в очереди: " + male_total + "\033[0m\n" );
            turn = true;                            // устанавливаем флаг, что при освобождении ванной комнаты в неё должны начать заходить мужчины
        }// if

        // использование notifyAll() вместо notify() может быть предпочтительнее, когда несколько потоков ожидают на одном объекте. В нашем случае wait
        notifyAll();                                // пробуждаем все ожидающие потоки, чтобы они могли проверить условия и продолжить
    }// exitFemale()


    /*----------------------------------------------------------*/
    /*    Метод запуска программы     */
    /*--------------------------------*/
    // main-метод, который запускает программу
    public static void main(String[] args) 
    {
        // \033[H перемещает курсор в верхний левый угол консоли
        // \033[2J очищает весь экран консоли       // заставляет поток вывода немедленно отправить все накопленные данные в устройство вывода (в данном случае, в консоль)
        System.out.print("\033[H\033[2J");          // чистим экран перед запуском программы    
        System.out.flush();
        // создаём объект класса для вывода надписей
        BathroomScheduler hi_scheduler = new BathroomScheduler(0,0);
        // выводим приветственную надпись
        hi_scheduler.print_start();
        
        // создаем объект класса Scanner для считывания ввода пользователя
        Scanner scanner = new Scanner(System.in);   // связываем созданный объект со стандартным вводом

        // работа с пользователем
        System.out.println("\033[38;5;160m\t\t\t\t\t П О Л Ь З О В А Т Е Л Ь С К И Й   В В О Д\033[0m\n");
    
        // запрашиваем у пользователя количество мужчин
        System.out.print("Введите количество мужчин: ");
        int numMales = scanner.nextInt();           // считываем целое число, введенное пользователем в консоль через объект scanner

        // запрашиваем у пользователя количество женщин
        System.out.print("Введите количество женщин: ");
        int numFemales = scanner.nextInt();         // считываем целое число, введенное пользователем в консоль через объект scanner
        scanner.nextLine();                         // очистка буфера ввода

        // создаем объект класса BathroomScheduler с введенными значениями, используя конструктор
        BathroomScheduler scheduler = new BathroomScheduler(numMales, numFemales);

        // создаём список потоков - динамически изменяемый объект
        // элементы списка имеют тип Thread
        // пустые угловые скобки <> указывают, что тип элементов в этом ArrayList будет определен из контекста
        List<Thread> threads = new ArrayList<>();

        // работа с потоками
        System.out.print("\n\033[38;5;215m\t\t\t\t\t     Р А Б О Т А   С   П О Т О К А М И\033[0m\n\n");

        // запускаем потоки для имитации входа мужчин в ванную комнату
        for (int i = 0; i < numMales; i++) 
        {
            // создаём новый поток с использованием лямбда-выражения с учетом того, что при создании используется один и тот же экземпляр класса, потому все описанные переменные и их изменения видны всем созданным потокам
            // суть лямбда-выражений:
            // когда вы запускаете новый поток, вы передаете ему объект Runnable, который содержит код, который должен выполняться в новом потоке.
            // когда новый поток запускается, он создает свое собственное стековое пространство и выполняет код, содержащийся в объекте Runnable.
            Thread maleThread = new Thread(() -> {
                // работа в плановом режиме
                try 
                {
                    scheduler.enterMale();          // вызываем метод экземпляра класса для управления входом мужчин в ванную комнату
                    Thread.sleep(300);              // имитируем время нахождения мужчины в ванной комнате
                    scheduler.exitMale();           // вызываем метод экземпляра класса для управления выходом мужчины из ванной комнаты
                }
                // когда поток находится в состоянии ожидания (например, при вызове wait(), sleep())
                // он прерывается. Ловим прерывание
                catch (InterruptedException e) 
                {
                    // устанавливаем флаг прерывания для текущего потока
                    // это означает, что флаг прерывания текущего потока будет установлен в true, указывая на то, что поток был прерван
                    Thread.currentThread().interrupt();
                    // когда у потока установлен флаг прерывания, это позволяет другим частям кода определить, что поток был прерван, и
                    // принять соответствующие действия
                }
            });
            maleThread.start();                     // запускаем созданный поток для мужчины
            threads.add(maleThread);                // добавляем только что созданный поток в список потоков
        }// for i

        // запускаем потоки для имитации входа женщин в ванную комнату
        for (int i = 0; i < numFemales; i++) 
        {
            // создаём новый поток с использованием лямбда-выражения с учетом того, что при создании используется один и тот же экземпляр класса, потому все описанные переменные и их изменения видны всем созданным потокам
            // суть лямбда-выражений:
            // когда вы запускаете новый поток, вы передаете ему объект Runnable, который содержит код, который должен выполняться в новом потоке.
            // когда новый поток запускается, он создает свое собственное стековое пространство и выполняет код, содержащийся в объекте Runnable.
            Thread femaleThread = new Thread(() -> {
                // работа в плановом режиме
                try 
                {
                    scheduler.enterFemale();        // вызываем метод экземпляра класса для управления входом женщин в ванную комнату
                    Thread.sleep(300);              // имитируем время нахождения женщины в ванной комнате
                    scheduler.exitFemale();         // вызываем метод экземпляра класса для управления выходом женщины из ванной комнаты
                }
                // когда поток находится в состоянии ожидания (например, при вызове wait(), sleep())
                // он прерывается. Ловим прерывание 
                catch (InterruptedException e) 
                {
                    // устанавливаем флаг прерывания для текущего потока
                    // это означает, что флаг прерывания текущего потока будет установлен в true, указывая на то, что поток был прерван
                    Thread.currentThread().interrupt();
                    // когда у потока установлен флаг прерывания, это позволяет другим частям кода определить, что поток был прерван, и
                    // принять соответствующие действия
                }
            });
            femaleThread.start();                   // запускаем созданный поток для женщины
            threads.add(femaleThread);              // добавляем только что созданный поток в список потоков
        }// for i


        // ждем, пока все созданные потоки завершатся
        for (Thread thread : threads)               // проходимся по всем созданным потокам из списка
        {
            // работа в плановом режиме
            try 
            {
                thread.join();                      // для каждого созанного элемента из списка блокируем основной поток до тех пор, пока все элементы не отработают
            }
            // во время ожидания завершения потока (thread.join()) возникает InterruptedException
            catch (InterruptedException e) 
            {
                Thread.currentThread().interrupt(); // устанавливаем флаг прерывания для текущего потока (основного потока)
                // это позволяет другим частям кода определить, что основной поток был прерван, и принять соответствующие действия.
            }
        }// for

        // после отработки всех потоков оповещаем о завершении программы
        System.out.println("\n\033[38;5;226mМ О Д Е Л И Р О В А Н И Е   В Ы П О Л Н Е Н О   У С П Е Ш Н О!   В С Е   Ч И С Т Ы Е\033[0m");
        hi_scheduler.print_end();                   // печатаем завершающую надпись
        System.out.print("Нажмите любую клавишу для продолжения...");
        scanner.nextLine();                         // ожидание нажатия клавиши
        scanner.close();                            // закрываем объект класса Scanner
    }// main()   

}// BathroomScheduler